# name: test/sql/level_pivot.test
# description: test level_pivot extension
# group: [sql]

require level_pivot

# ATTACH a LevelDB database
statement ok
ATTACH '__TEST_DIR__/test_leveldb' AS testdb (TYPE level_pivot, READ_ONLY false, CREATE_IF_MISSING true);

# Create a pivot table
statement ok
CALL level_pivot_create_table('testdb', 'users', 'users##{group}##{id}##{attr}', ['group', 'id', 'name', 'email']);

# INSERT
statement ok
INSERT INTO testdb.users VALUES ('admins', 'u1', 'Alice', 'alice@ex.com');

statement ok
INSERT INTO testdb.users VALUES ('admins', 'u2', 'Bob', 'bob@ex.com');

statement ok
INSERT INTO testdb.users VALUES ('viewers', 'u3', 'Charlie', 'charlie@ex.com');

# SELECT all
query IIII rowsort
SELECT * FROM testdb.users;
----
admins	u1	Alice	alice@ex.com
admins	u2	Bob	bob@ex.com
viewers	u3	Charlie	charlie@ex.com

# SELECT with filter
query IIII
SELECT * FROM testdb.users WHERE "group" = 'admins' AND id = 'u1';
----
admins	u1	Alice	alice@ex.com

# UPDATE
statement ok
UPDATE testdb.users SET email = 'newalice@ex.com' WHERE "group" = 'admins' AND id = 'u1';

query IIII
SELECT * FROM testdb.users WHERE "group" = 'admins' AND id = 'u1';
----
admins	u1	Alice	newalice@ex.com

# DELETE
statement ok
DELETE FROM testdb.users WHERE "group" = 'viewers' AND id = 'u3';

query I
SELECT count(*) FROM testdb.users;
----
2

# Create a raw table
statement ok
CALL level_pivot_create_table('testdb', 'kv', NULL, ['key', 'value'], table_mode := 'raw');

# INSERT into raw table
statement ok
INSERT INTO testdb.kv VALUES ('hello', 'world');

statement ok
INSERT INTO testdb.kv VALUES ('foo', 'bar');

# SELECT from raw table (raw tables see all keys in the database, filter to our keys)
query II rowsort
SELECT * FROM testdb.kv WHERE key IN ('foo', 'hello');
----
foo	bar
hello	world

# DELETE from raw table
statement ok
DELETE FROM testdb.kv WHERE key = 'foo';

query I
SELECT count(*) FROM testdb.kv WHERE key IN ('foo', 'hello');
----
1

# ===== Filter pushdown tests =====

# Re-insert deleted user for filter tests
statement ok
INSERT INTO testdb.users VALUES ('viewers', 'u3', 'Charlie', 'charlie@ex.com');

# Filter on first identity column only (partial prefix)
query IIII rowsort
SELECT * FROM testdb.users WHERE "group" = 'admins';
----
admins	u1	Alice	newalice@ex.com
admins	u2	Bob	bob@ex.com

# Filter on both identity columns (full prefix)
query IIII
SELECT * FROM testdb.users WHERE "group" = 'admins' AND id = 'u2';
----
admins	u2	Bob	bob@ex.com

# Filter on second identity column only (no prefix optimization, still works via post-filter)
query IIII
SELECT * FROM testdb.users WHERE id = 'u3';
----
viewers	u3	Charlie	charlie@ex.com

# Filter with no results
query I
SELECT count(*) FROM testdb.users WHERE "group" = 'nonexistent';
----
0

# Filter on attr column (no prefix optimization, post-filter only)
query IIII
SELECT * FROM testdb.users WHERE name = 'Bob';
----
admins	u2	Bob	bob@ex.com

# ===== Multi-row insert =====
statement ok
INSERT INTO testdb.users VALUES ('editors', 'u4', 'Diana', 'diana@ex.com'), ('editors', 'u5', 'Eve', 'eve@ex.com');

query IIII rowsort
SELECT * FROM testdb.users WHERE "group" = 'editors';
----
editors	u4	Diana	diana@ex.com
editors	u5	Eve	eve@ex.com

# ===== NULL handling =====

# Insert with NULL attr
statement ok
INSERT INTO testdb.users VALUES ('testers', 'u6', 'Frank', NULL);

query IIII
SELECT * FROM testdb.users WHERE "group" = 'testers' AND id = 'u6';
----
testers	u6	Frank	NULL

# Update to set NULL - when all attrs are NULL, the row vanishes from pivot
# (no LevelDB keys remain for this identity)
statement ok
UPDATE testdb.users SET name = NULL WHERE "group" = 'testers' AND id = 'u6';

query I
SELECT count(*) FROM testdb.users WHERE "group" = 'testers' AND id = 'u6';
----
0

# ===== Raw table UPDATE =====
statement ok
UPDATE testdb.kv SET value = 'universe' WHERE key = 'hello';

query II
SELECT * FROM testdb.kv WHERE key = 'hello';
----
hello	universe

# ===== DETACH and re-ATTACH (data persists) =====
statement ok
DETACH testdb;

statement ok
ATTACH '__TEST_DIR__/test_leveldb' AS testdb (TYPE level_pivot, READ_ONLY false, CREATE_IF_MISSING false);

# Re-create table definitions (transient, lost on detach)
statement ok
CALL level_pivot_create_table('testdb', 'users', 'users##{group}##{id}##{attr}', ['group', 'id', 'name', 'email']);

statement ok
CALL level_pivot_create_table('testdb', 'kv', NULL, ['key', 'value'], table_mode := 'raw');

# Verify data survived detach/attach (u6 vanished because all attrs NULL)
query I
SELECT count(*) FROM testdb.users;
----
5

query II
SELECT * FROM testdb.kv WHERE key = 'hello';
----
hello	universe

# ===== DROP TABLE =====

# Drop the kv table
statement ok
CALL level_pivot_drop_table('testdb', 'kv');

# Verify kv table is gone
statement error
SELECT * FROM testdb.kv;
----
Catalog Error

# Verify users table still works after dropping kv
query I
SELECT count(*) FROM testdb.users;
----
5

# ===== Column projection =====

# SELECT specific columns (tests projection pushdown)
query II rowsort
SELECT name, email FROM testdb.users WHERE "group" = 'admins';
----
Alice	newalice@ex.com
Bob	bob@ex.com

# SELECT single identity column
query I rowsort
SELECT id FROM testdb.users WHERE "group" = 'editors';
----
u4
u5

# ===== INSERT INTO ... SELECT =====

# Create a second pivot table
statement ok
CALL level_pivot_create_table('testdb', 'users_backup', 'users_backup##{group}##{id}##{attr}', ['group', 'id', 'name', 'email']);

# Copy admins via INSERT INTO ... SELECT
statement ok
INSERT INTO testdb.users_backup SELECT * FROM testdb.users WHERE "group" = 'admins';

query IIII rowsort
SELECT * FROM testdb.users_backup;
----
admins	u1	Alice	newalice@ex.com
admins	u2	Bob	bob@ex.com

# Drop backup table
statement ok
CALL level_pivot_drop_table('testdb', 'users_backup');

# ===== SHOW TABLES integration =====

query I
SELECT table_name FROM information_schema.tables WHERE table_catalog = 'testdb';
----
users

# ===== Error conditions =====

# Pivot table without pattern should error
statement error
CALL level_pivot_create_table('testdb', 'bad_table', NULL, ['a', 'b']);
----
Pattern is required for pivot tables

# Raw table with wrong column count should error
statement error
CALL level_pivot_create_table('testdb', 'bad_raw', NULL, ['a', 'b', 'c'], table_mode := 'raw');
----
Raw tables must have exactly 2 columns

# Invalid table_mode should error
statement error
CALL level_pivot_create_table('testdb', 'bad', 'bad##{k}##{attr}', ['k', 'v'], table_mode := 'invalid');
----
Invalid table_mode

# ===== Typed column tests =====

# Create a typed pivot table with BIGINT and DOUBLE columns
statement ok
CALL level_pivot_create_table('testdb', 'metrics', 'metrics##{host}##{ts}##{attr}', ['host', 'ts', 'cpu_pct', 'mem_mb'], column_types := ['VARCHAR', 'BIGINT', 'DOUBLE', 'BIGINT']);

# INSERT typed values
statement ok
INSERT INTO testdb.metrics VALUES ('srv1', 1000, 55.5, 2048);

statement ok
INSERT INTO testdb.metrics VALUES ('srv1', 2000, 72.3, 4096);

statement ok
INSERT INTO testdb.metrics VALUES ('srv2', 1500, 30.0, 1024);

# Verify arithmetic works (SUM, MAX on typed columns)
query IR
SELECT SUM(mem_mb), MAX(cpu_pct) FROM testdb.metrics;
----
7168	72.3

# Verify typed numeric comparison (not string comparison)
# With string comparison, '2000' < '500' but with BIGINT, 2000 > 500
query IIRI rowsort
SELECT * FROM testdb.metrics WHERE ts > 1500;
----
srv1	2000	72.3	4096

# UPDATE with typed filter
statement ok
UPDATE testdb.metrics SET cpu_pct = 99.9 WHERE host = 'srv2' AND ts = 1500;

query IR
SELECT cpu_pct, mem_mb FROM testdb.metrics WHERE host = 'srv2' AND ts = 1500;
----
99.9	1024

# DELETE with typed filter
statement ok
DELETE FROM testdb.metrics WHERE host = 'srv1' AND ts = 1000;

query I
SELECT count(*) FROM testdb.metrics;
----
2

# Test BOOLEAN type round-trip
statement ok
CALL level_pivot_create_table('testdb', 'flags', 'flags##{name}##{attr}', ['name', 'active', 'count'], column_types := ['VARCHAR', 'BOOLEAN', 'INTEGER']);

statement ok
INSERT INTO testdb.flags VALUES ('feature_x', true, 42);

statement ok
INSERT INTO testdb.flags VALUES ('feature_y', false, 0);

query IRI rowsort
SELECT * FROM testdb.flags;
----
feature_x	true	42
feature_y	false	0

# Verify boolean filter works
query I
SELECT name FROM testdb.flags WHERE active = true;
----
feature_x

# Test backward compatibility (no column_types = all VARCHAR)
statement ok
CALL level_pivot_create_table('testdb', 'compat', 'compat##{k}##{attr}', ['k', 'v']);

statement ok
INSERT INTO testdb.compat VALUES ('a', 'hello');

query II
SELECT * FROM testdb.compat;
----
a	hello

# Test error: mismatched column_types/column_names length
statement error
CALL level_pivot_create_table('testdb', 'bad_types', 'bad##{k}##{attr}', ['k', 'v'], column_types := ['VARCHAR']);
----
column_types length

# Clean up typed tables
statement ok
CALL level_pivot_drop_table('testdb', 'metrics');

statement ok
CALL level_pivot_drop_table('testdb', 'flags');

statement ok
CALL level_pivot_drop_table('testdb', 'compat');

# ===== Dirty table tracking tests =====

# Create a raw table for dirty tracking tests
statement ok
CALL level_pivot_create_table('testdb', 'kv2', NULL, ['key', 'value'], table_mode := 'raw');

# No writes yet in this transaction context → empty result
query I
SELECT count(*) FROM level_pivot_dirty_tables();
----
0

# Insert into pivot table → marks both users (pivot match) and kv2 (raw, always dirty)
statement ok
BEGIN;

statement ok
INSERT INTO testdb.users VALUES ('dirty_test', 'dt1', 'Test', 'test@ex.com');

query III rowsort
SELECT * FROM level_pivot_dirty_tables();
----
testdb	kv2	raw
testdb	users	pivot

statement ok
ROLLBACK;

# After rollback, dirty state is cleared (new transaction)
query I
SELECT count(*) FROM level_pivot_dirty_tables();
----
0

# Update also marks tables dirty
statement ok
BEGIN;

statement ok
UPDATE testdb.users SET email = 'updated@ex.com' WHERE "group" = 'admins' AND id = 'u1';

query III rowsort
SELECT * FROM level_pivot_dirty_tables();
----
testdb	kv2	raw
testdb	users	pivot

statement ok
ROLLBACK;

# Delete also marks tables dirty
statement ok
BEGIN;

statement ok
DELETE FROM testdb.users WHERE "group" = 'editors' AND id = 'u4';

query III rowsort
SELECT * FROM level_pivot_dirty_tables();
----
testdb	kv2	raw
testdb	users	pivot

statement ok
ROLLBACK;

# Raw table insert marks the raw table + matching pivot tables
statement ok
BEGIN;

statement ok
INSERT INTO testdb.kv2 VALUES ('users##somegroup##someid##name', 'SomeUser');

query III rowsort
SELECT * FROM level_pivot_dirty_tables();
----
testdb	kv2	raw
testdb	users	pivot

statement ok
ROLLBACK;

# Raw table insert with non-matching key only marks the raw table
statement ok
BEGIN;

statement ok
INSERT INTO testdb.kv2 VALUES ('something_else', 'value');

query III rowsort
SELECT * FROM level_pivot_dirty_tables();
----
testdb	kv2	raw

statement ok
ROLLBACK;

# Clean up residual data from dirty tracking tests
# (LevelDB writes persist through DuckDB ROLLBACK since LevelDB has no transactions)
statement ok
DELETE FROM testdb.users WHERE "group" = 'dirty_test';

statement ok
CALL level_pivot_drop_table('testdb', 'kv2');

# Final DETACH
statement ok
DETACH testdb;

# ===== Read-only mode =====

# Re-attach as read-only
statement ok
ATTACH '__TEST_DIR__/test_leveldb' AS testdb_ro (TYPE level_pivot, READ_ONLY true);

# Re-create table definition
statement ok
CALL level_pivot_create_table('testdb_ro', 'users', 'users##{group}##{id}##{attr}', ['group', 'id', 'name', 'email']);

# SELECT should work on read-only
query I
SELECT count(*) FROM testdb_ro.users;
----
5

# INSERT should fail on read-only
statement error
INSERT INTO testdb_ro.users VALUES ('ro_test', 'u99', 'Nobody', 'no@ex.com');
----
attached in read-only mode

# DELETE should fail on read-only
statement error
DELETE FROM testdb_ro.users WHERE "group" = 'admins' AND id = 'u1';
----
attached in read-only mode

# UPDATE should fail on read-only
statement error
UPDATE testdb_ro.users SET email = 'x' WHERE "group" = 'admins' AND id = 'u1';
----
attached in read-only mode

# Detach read-only
statement ok
DETACH testdb_ro;
